Index: xproto.h
===================================================================
--- xproto.h	(wersja 1725)
+++ xproto.h	(kopia robocza)
@@ -12,5 +12,6 @@
 void ewmh_set_icon(Window wnd, int width, int height, const char *rgba_data);
 void ewmh_del_icon(Window wnd, int width, int height);
 int ewmh_set_window_above(Window wnd);
+RD_BOOL ewmh_is_window_above(Window w);
 void set_keypress_keysym(unsigned int keycode, KeySym keysym);
 KeySym reset_keypress_keysym(unsigned int keycode, KeySym keysym);
Index: rdpsnd_dsp.c
===================================================================
--- rdpsnd_dsp.c	(wersja 1725)
+++ rdpsnd_dsp.c	(kopia robocza)
@@ -255,7 +255,7 @@
 #ifdef HAVE_LIBSAMPLERATE
 	if (src_converter == NULL)
 	{
-		warning("no samplerate converter available!!\n");
+		warning("no samplerate converter available!\n");
 		return 0;
 	}
 
Index: proto.h
===================================================================
--- proto.h	(wersja 1725)
+++ proto.h	(kopia robocza)
@@ -144,6 +144,7 @@
 char *l_to_a(long N, int base);
 int load_licence(unsigned char **data);
 void save_licence(unsigned char *data, int length);
+void rd_create_ui(void);
 RD_BOOL rd_pstcache_mkdir(void);
 int rd_open_file(char *filename);
 void rd_close_file(int fd);
Index: seamless.c
===================================================================
--- seamless.c	(wersja 1725)
+++ seamless.c	(kopia robocza)
@@ -437,7 +437,7 @@
 	s = channel_init(seamless_channel, len);
 	out_uint8p(s, buf, len) s_mark_end(s);
 
-	DEBUG_SEAMLESS(("SeamlessRDP sending:%s", buf));
+	DEBUG_SEAMLESS(("seamlessrdp sending:%s", buf));
 
 #if 0
 	printf("seamless send:\n");
Index: doc/rdesktop.1
===================================================================
--- doc/rdesktop.1	(wersja 1725)
+++ doc/rdesktop.1	(kopia robocza)
@@ -282,6 +282,16 @@
 The server denied the connection
 .IP "\fB8\fP"
 The server denied the connection for security reason
+.IP "\fB9\fP"
+The user cannot connect to the server due to insufficient access
+privileges
+.IP "\fB10\fP"
+The server does not accept saved user credentials and requires that
+the user enter their credentials for each connection
+.IP "\fB11\fP"
+Disconnect initiated by administration tool
+.IP "\fB12\fP"
+Disconnect initiated by user
 .IP "\fB16\fP"
 Internal licensing error
 .IP "\fB17\fP"
Index: rdp.c
===================================================================
--- rdp.c	(wersja 1725)
+++ rdp.c	(kopia robocza)
@@ -1044,6 +1044,9 @@
 	uint8 type;
 	uint16 len_src_descriptor, len_combined_caps;
 
+	/* at this point we need to ensure that we have ui created */
+	rd_create_ui();
+
 	in_uint32_le(s, g_rdp_shareid);
 	in_uint16_le(s, len_src_descriptor);
 	in_uint16_le(s, len_combined_caps);
Index: rdesktop.c
===================================================================
--- rdesktop.c	(wersja 1725)
+++ rdesktop.c	(kopia robocza)
@@ -281,7 +281,6 @@
 			break;
 
 		case exDiscReasonAPIInitiatedDisconnect:
-		case exDiscReasonWindows7Disconnect:
 			text = "Server initiated disconnect";
 			retval = EXRD_API_DISCONNECT;
 			break;
@@ -321,6 +320,26 @@
 			retval = EXRD_DENIED_FIPS;
 			break;
 
+		case exDiscReasonServerInsufficientPrivileges:
+			text = "The user cannot connect to the server due to insufficient access privileges.";
+			retval = EXRD_INSUFFICIENT_PRIVILEGES;
+			break;
+
+		case exDiscReasonServerFreshCredentialsRequired:
+			text = "The server does not accept saved user credentials and requires that the user enter their credentials for each connection.";
+			retval = EXRD_FRESH_CREDENTIALS_REQUIRED;
+			break;
+
+		case exDiscReasonRPCInitiatedDisconnectByUser:
+			text = "Disconnect initiated by administration tool";
+			retval = EXRD_RPC_DISCONNECT_BY_USER;
+			break;
+
+		case exDiscReasonByUser:
+			text = "Disconnect initiated by user";
+			retval = EXRD_DISCONNECT_BY_USER;
+			break;
+
 		case exDiscReasonLicenseInternal:
 			text = "Internal licensing error";
 			retval = EXRD_LIC_INTERNAL;
@@ -510,7 +529,6 @@
 #ifdef WITH_RDPSND
 	char *rdpsnd_optarg = NULL;
 #endif
-	int longidx;
 
 #ifdef HAVE_LOCALE_H
 	/* Set locale according to environment */
@@ -1132,15 +1150,10 @@
 		DEBUG(("Connection successful.\n"));
 		memset(password, 0, sizeof(password));
 
-		/* only create a window if we dont have one intialized */
-		if (!ui_have_window())
-		{
-			if (!ui_create_window())
-				return EX_OSERR;
-		}
-
+		rd_create_ui();
 		tcp_run_ui(True);
 
+		deactivated = False;
 		g_redirect = False;
 		g_reconnect_loop = False;
 		rdp_main_loop(&deactivated, &ext_disc_reason);
@@ -1154,7 +1167,7 @@
 			continue;
 
 		/* handle network error and start autoreconnect */
-		if (g_network_error)
+		if (g_network_error && !deactivated)
 		{
 			fprintf(stderr,
 				"Disconnected due to network error, retrying to reconnect for %d minutes.\n",
@@ -1732,6 +1745,18 @@
 	close(fd);
 }
 
+/* create rdesktop ui */
+void
+rd_create_ui()
+{
+	/* only create a window if we dont have one intialized */
+	if (!ui_have_window())
+	{
+		if (!ui_create_window())
+			exit(EX_OSERR);
+	}
+}
+
 /* Create the bitmap cache directory */
 RD_BOOL
 rd_pstcache_mkdir(void)
Index: ewmhints.c
===================================================================
--- ewmhints.c	(wersja 1725)
+++ ewmhints.c	(kopia robocza)
@@ -203,7 +203,7 @@
 {
 	unsigned long nitems_return;
 	unsigned char *prop_return;
-	uint32 *return_words;
+	unsigned long *return_words;
 	unsigned long item;
 	RD_BOOL maximized_vert, maximized_horz, hidden;
 
@@ -212,7 +212,7 @@
 	if (get_property_value(w, "_NET_WM_STATE", 64, &nitems_return, &prop_return, 0) < 0)
 		return SEAMLESSRDP_NORMAL;
 
-	return_words = (uint32 *) prop_return;
+	return_words = (unsigned long *) prop_return;
 
 	for (item = 0; item < nitems_return; item++)
 	{
@@ -226,10 +226,11 @@
 
 	XFree(prop_return);
 
-	if (maximized_vert && maximized_horz)
+	/* In EWMH, HIDDEN overrides MAXIMIZED_VERT/MAXIMIZED_HORZ */
+	if (hidden)
+		return SEAMLESSRDP_MINIMIZED;
+	else if (maximized_vert && maximized_horz)
 		return SEAMLESSRDP_MAXIMIZED;
-	else if (hidden)
-		return SEAMLESSRDP_MINIMIZED;
 	else
 		return SEAMLESSRDP_NORMAL;
 }
@@ -542,6 +543,33 @@
 	return 0;
 }
 
+RD_BOOL
+ewmh_is_window_above(Window w)
+{
+	unsigned long nitems_return;
+	unsigned char *prop_return;
+	unsigned long *return_words;
+	unsigned long item;
+	RD_BOOL above;
+
+	above = False;
+
+	if (get_property_value(w, "_NET_WM_STATE", 64, &nitems_return, &prop_return, 0) < 0)
+		return False;
+
+	return_words = (unsigned long *) prop_return;
+
+	for (item = 0; item < nitems_return; item++)
+	{
+		if (return_words[item] == g_net_wm_state_above_atom)
+			above = True;
+	}
+
+	XFree(prop_return);
+
+	return above;
+}
+
 #endif /* MAKE_PROTO */
 
 
Index: rdesktop.h
===================================================================
--- rdesktop.h	(wersja 1725)
+++ rdesktop.h	(kopia robocza)
@@ -100,6 +100,10 @@
 #define EXRD_OUT_OF_MEM 6
 #define EXRD_DENIED 7
 #define EXRD_DENIED_FIPS 8
+#define EXRD_INSUFFICIENT_PRIVILEGES 9
+#define EXRD_FRESH_CREDENTIALS_REQUIRED 10
+#define EXRD_RPC_DISCONNECT_BY_USER 11
+#define EXRD_DISCONNECT_BY_USER 12
 #define EXRD_LIC_INTERNAL 16
 #define EXRD_LIC_NOSERVER 17
 #define EXRD_LIC_NOLICENSE 18
Index: tcp.c
===================================================================
--- tcp.c	(wersja 1725)
+++ tcp.c	(kopia robocza)
@@ -193,7 +193,7 @@
 	int rcvd = 0, ssl_err;
 
 	if (g_network_error == True)
-		return;
+		return NULL;
 
 	if (s == NULL)
 	{
@@ -318,7 +318,9 @@
 		}
 
 		options = 0;
+#ifdef SSL_OP_NO_COMPRESSION
 		options |= SSL_OP_NO_COMPRESSION;
+#endif // __SSL_OP_NO_COMPRESSION
 		options |= SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
 		SSL_CTX_set_options(g_ssl_ctx, options);
 	}
Index: scard.c
===================================================================
--- scard.c	(wersja 1725)
+++ scard.c	(kopia robocza)
@@ -2,8 +2,8 @@
    rdesktop: A Remote Desktop Protocol client.
    Smart Card support
    Copyright (C) Alexi Volkov <alexi@myrealbox.com> 2006
-   Copyright 2010 Pierre Ossman <ossman@cendio.se> for Cendio AB
-   Copyright 2011 Henrik Andersson <hean01@cendio.se> for Cendio AB
+   Copyright 2010-2013 Pierre Ossman <ossman@cendio.se> for Cendio AB
+   Copyright 2011-2013 Henrik Andersson <hean01@cendio.se> for Cendio AB
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1109,6 +1109,7 @@
 	MYPCSC_SCARDCONTEXT myHContext;
 	SERVER_DWORD dwTimeout;
 	SERVER_DWORD dwCount;
+	SERVER_DWORD dwPointerId;
 	SERVER_LPSCARD_READERSTATE_A rsArray, cur;
 	MYPCSC_LPSCARD_READERSTATE_A myRsArray;
 	long i;
@@ -1133,7 +1134,8 @@
 		memset(rsArray, 0, dwCount * sizeof(SERVER_SCARD_READERSTATE_A));
 		for (i = 0, cur = rsArray; i < dwCount; i++, cur++)
 		{
-			in_uint32_le(in, cur->szReader);
+			in_uint32_le(in, dwPointerId);
+			cur->szReader = (char *) (intptr_t) dwPointerId;
 			in_uint32_le(in, cur->dwCurrentState);
 			in_uint32_le(in, cur->dwEventState);
 			in_uint32_le(in, cur->cbAtr);
@@ -1989,26 +1991,6 @@
 	rv = SCardGetAttrib(myHCard, (MYPCSC_DWORD) dwAttrId, pbAttr, &attrLen);
 	dwAttrLen = attrLen;
 
-	if (dwAttrId == SCARD_ATTR_VENDOR_NAME && rv != SCARD_S_SUCCESS)
-	{
-		DEBUG_SCARD(("SCARD:    Faking attribute ATTR_VENDOR_NAME\n"));
-		pthread_mutex_lock(&hcardAccess);
-		PSCHCardRec hcard = hcardFirst;
-		while (hcard)
-		{
-			if (hcard->hCard == hCard)
-			{
-				dwAttrLen = strlen(hcard->vendor);
-				memcpy(pbAttr, hcard->vendor, dwAttrLen);
-				rv = SCARD_S_SUCCESS;
-				break;
-			}
-			hcard = hcard->next;
-		}
-		pthread_mutex_unlock(&hcardAccess);
-		DEBUG_SCARD(("[0x%.8x]\n", (unsigned int) rv));
-	}
-
 	if (rv != SCARD_S_SUCCESS)
 	{
 		DEBUG_SCARD(("SCARD: -> Failure: %s (0x%08x)\n",
Index: constants.h
===================================================================
--- constants.h	(wersja 1725)
+++ constants.h	(kopia robocza)
@@ -454,7 +454,10 @@
 #define exDiscReasonOutOfMemory				0x0006
 #define exDiscReasonServerDeniedConnection		0x0007
 #define exDiscReasonServerDeniedConnectionFips		0x0008
-#define exDiscReasonWindows7Disconnect                  0x000b	/* unofficial */
+#define exDiscReasonServerInsufficientPrivileges        0x0009
+#define exDiscReasonServerFreshCredentialsRequired      0x000a
+#define exDiscReasonRPCInitiatedDisconnectByUser        0x000b
+#define exDiscReasonByUser                              0x000c
 #define exDiscReasonLicenseInternal			0x0100
 #define exDiscReasonLicenseNoLicenseServer		0x0101
 #define exDiscReasonLicenseNoLicense			0x0102
Index: rdpsnd_libao.c
===================================================================
--- rdpsnd_libao.c	(wersja 1725)
+++ rdpsnd_libao.c	(kopia robocza)
@@ -111,6 +111,7 @@
 {
 	ao_sample_format format;
 
+	memset(&format, 0, sizeof(format));
 	format.bits = pwfx->wBitsPerSample;
 	format.channels = pwfx->nChannels;
 	format.rate = 44100;
Index: rdesktop.spec
===================================================================
--- rdesktop.spec	(wersja 1725)
+++ rdesktop.spec	(kopia robocza)
@@ -1,6 +1,6 @@
 Summary: Remote Desktop Protocol client
 Name: rdesktop
-Version: 1.8.0
+Version: 1.8.0post
 Release: 1
 License: GPL; see COPYING
 Group: Applications/Communications
Index: xwin.c
===================================================================
--- xwin.c	(wersja 1725)
+++ xwin.c	(kopia robocza)
@@ -574,14 +574,14 @@
 	XEvent xevent;
 	sw_configurenotify_context context;
 	struct timeval now;
-	struct timeval nextsecond;
+	struct timeval future;
 	RD_BOOL got = False;
 
 	context.window = wnd;
 	context.serial = serial;
 
-	gettimeofday(&nextsecond, NULL);
-	nextsecond.tv_sec += 1;
+	gettimeofday(&future, NULL);
+	future.tv_usec += 500000;
 
 	do
 	{
@@ -593,7 +593,7 @@
 		usleep(100000);
 		gettimeofday(&now, NULL);
 	}
-	while (timercmp(&now, &nextsecond, <));
+	while (timercmp(&now, &future, <));
 
 	if (!got)
 	{
@@ -4181,11 +4181,6 @@
 		/* X11 windows must be at least 1x1 */
 		return;
 
-	sw->xoffset = x;
-	sw->yoffset = y;
-	sw->width = width;
-	sw->height = height;
-
 	/* If we move the window in a maximized state, then KDE won't
 	   accept restoration */
 	switch (sw->state)
@@ -4192,9 +4187,15 @@
 	{
 		case SEAMLESSRDP_MINIMIZED:
 		case SEAMLESSRDP_MAXIMIZED:
+			sw_update_position(sw);
 			return;
 	}
 
+	sw->xoffset = x;
+	sw->yoffset = y;
+	sw->width = width;
+	sw->height = height;
+
 	/* FIXME: Perhaps use ewmh_net_moveresize_window instead */
 	XMoveResizeWindow(g_display, sw->wnd, sw->xoffset, sw->yoffset, sw->width, sw->height);
 }
@@ -4206,6 +4207,7 @@
 	seamless_window *sw;
 	XWindowChanges values;
 	unsigned long restack_serial;
+	unsigned int value_mask;
 
 	if (!g_seamless_active)
 		return;
@@ -4228,25 +4230,43 @@
 			return;
 		}
 
-		if (!g_seamless_broken_restack)
+		values.stack_mode = Below;
+		value_mask = CWStackMode | CWSibling;
+		values.sibling = sw_behind->wnd;
+
+		/* Avoid that topmost windows references non-topmost
+		   windows, and vice versa. */
+		if (ewmh_is_window_above(sw->wnd))
 		{
-			values.stack_mode = Below;
-			values.sibling = sw_behind->wnd;
-			restack_serial = XNextRequest(g_display);
-			XReconfigureWMWindow(g_display, sw->wnd, DefaultScreen(g_display),
-					     CWStackMode | CWSibling, &values);
-			sw_wait_configurenotify(sw->wnd, restack_serial);
+			if (!ewmh_is_window_above(sw_behind->wnd))
+			{
+				/* Disallow, move to bottom of the
+				   topmost stack. */
+				values.stack_mode = Below;
+				value_mask = CWStackMode;	/* Not sibling */
+			}
 		}
+		else
+		{
+			if (ewmh_is_window_above(sw_behind->wnd))
+			{
+				/* Move to top of non-topmost
+				   stack. */
+				values.stack_mode = Above;
+				value_mask = CWStackMode;	/* Not sibling */
+			}
+		}
 	}
 	else
 	{
 		values.stack_mode = Above;
-		restack_serial = XNextRequest(g_display);
-		XReconfigureWMWindow(g_display, sw->wnd, DefaultScreen(g_display), CWStackMode,
-				     &values);
-		sw_wait_configurenotify(sw->wnd, restack_serial);
+		value_mask = CWStackMode;
 	}
 
+	restack_serial = XNextRequest(g_display);
+	XReconfigureWMWindow(g_display, sw->wnd, DefaultScreen(g_display), value_mask, &values);
+	sw_wait_configurenotify(sw->wnd, restack_serial);
+
 	sw_restack_window(sw, behind);
 
 	if (flags & SEAMLESSRDP_CREATE_TOPMOST)
